# Write your code implementation here. 

''' Remember the input to this file should be a .graph file and the output should be a .out file. 
    Your script shoudl run with the following format : 
        python3 main.py student_test_cases/NAME.graph
    The output file must have the same name as the input file, i.e., for a NAME.graph input file, the output file should be NAME.out.

    There must also be a corresponding NAME.truth file in the student_test_cases directory. If there is no corresponding .truth file, the test case will be scored as zero.
    
    If you change any of the directory names, please update the makefile accordingly.

    Directories:
    - student-test-cases : Directory containing your .graph and .truth files.
    - student-test-outputs : Directory to store .out files temporarily before scoring. DO NOT SAVE FILES TO THIS DIRECTORY MANUALLY.
    - makefile : The makefile to run and score your tests.
    - test-instances: Directory containing common test cases (do not modify).
    - outputs: Directory to store .out files generated by your script for test cases.

    Makefile Targets:
    - make run : Runs your main.py script on all .graph files in student-test-cases and test-instances directories.
                main.py should generate .out files in the outputs directory.
    - make score : Scores the generated .out files against the corresponding .truth files and provides a score. Only for instructor use.
    - make clean : Cleans up all generated .out files from the outputs directory.
    - make all : Runs both 'make run' and 'make score' sequentially.
'''

from collections import defaultdict, deque
import io
import sys

# ================================================================
# Utility: Build adjacency list with only edges that have f > 0
# ================================================================
def build_graph(flow):
    graph = defaultdict(list)
    for (u, v), w in flow.items():
        if w > 0:
            graph[u].append((v, w))
    return graph


# ================================================================
# Find *one* directed cycle using DFS
# Returns: list of vertices forming the cycle (cycle[0] = cycle[-1])
# ================================================================
def find_cycle(graph):
    visited = set()
    stack = set()
    parent = {}

    def dfs(u):
        visited.add(u)
        stack.add(u)

        for v, _ in graph.get(u, []):     # <-- safe access
            if v not in visited:
                parent[v] = u
                res = dfs(v)
                if res:
                    return res
            elif v in stack:
                # reconstruct cycle
                cycle = [v]
                cur = u
                while cur != v:
                    cycle.append(cur)
                    cur = parent[cur]
                cycle.append(v)
                cycle.reverse()
                return cycle

        stack.remove(u)
        return None

    # snapshot of keys so graph can change under DFS
    for u in list(graph.keys()):
        if u not in visited:
            parent[u] = None
            res = dfs(u)
            if res:
                return res

    return None


# ================================================================
# Given a cycle, compute bottleneck weight and apply subtraction
# ================================================================
def extract_cycle(cycle, flow, cycles):
    # Compute bottleneck
    w = min(flow[(cycle[i], cycle[i+1])] for i in range(len(cycle)-1))

    # Record
    cycles.append((w, cycle.copy()))

    # Subtract flow
    for i in range(len(cycle)-1):
        e = (cycle[i], cycle[i+1])
        flow[e] -= w
        if flow[e] == 0:
            del flow[e]


# ================================================================
# Find a "good" s→t path using BFS, but biased toward long paths
# ================================================================
def find_st_path(graph, s, t):
    # BFS but save parents for reconstruction
    parent = {s: None}
    q = deque([s])

    while q:
        u = q.popleft()
        if u == t:
            break
        for v, _ in graph[u]:
            if v not in parent:
                parent[v] = u
                q.append(v)

    if t not in parent:
        return None

    # Reconstruct path
    path = []
    cur = t
    while cur is not None:
        path.append(cur)
        cur = parent[cur]
    path.reverse()
    return path


# ================================================================
# Given path, subtract bottleneck and record
# ================================================================
def extract_path(path, flow, paths):
    # bottleneck weight
    w = min(flow[(path[i], path[i+1])] for i in range(len(path)-1))

    paths.append((w, path.copy()))

    # subtract
    for i in range(len(path)-1):
        e = (path[i], path[i+1])
        flow[e] -= w
        if flow[e] == 0:
            del flow[e]


# ================================================================
# Main decomposition routine
# ================================================================
def decompose_flow(V, flow, s, t):
    paths = []
    cycles = []

    # ---------------------------
    # Phase 1: Remove cycles early
    # ---------------------------
    while True:
        graph = build_graph(flow)
        cyc = find_cycle(graph)
        if not cyc:
            break
        extract_cycle(cyc, flow, cycles)

    # ---------------------------
    # Phase 2: Extract s→t paths
    # ---------------------------
    while True:
        graph = build_graph(flow)
        if t not in graph and all(t not in [v for v,_ in nbrs] for nbrs in graph.values()):
            break

        p = find_st_path(graph, s, t)
        if not p:
            break
        extract_path(p, flow, paths)

    # ---------------------------
    # Phase 3: Remove remaining cycles
    # ---------------------------
    while True:
        graph = build_graph(flow)
        cyc = find_cycle(graph)
        if not cyc:
            break
        extract_cycle(cyc, flow, cycles)

    return paths, cycles


def read_flow_graph(file_content: str) -> dict:
    """
    Reads the content of a graph file (as specified in the project description)
    and returns a dictionary mapping (u, v) edges to their flow value f(e).

    Args:
        file_content: The entire content of the .graph file as a single string.

    Returns:
        A dictionary where keys are (u, v) tuples (int, int) and values
        are the flow f(e) (int).
    """
    flow_dict = {}
    
    # Use io.StringIO to treat the string content as a file
    file_stream = io.StringIO(file_content)
    V=0
    E=0
    
    # 1. Read the first line (skip |V| and |E|)
    try:
        # This line is needed to discard the header but also to get |V| and |E| if needed later
        header = file_stream.readline().strip()
        if not header:
            return flow_dict # Empty file
        
        # We can extract |V| and |E| here, though not strictly needed for the flow_dict
        V, E = map(int, header.split())
        
    except ValueError:
        # Handle case where the first line is malformed
        return flow_dict
        
    # 2. Iterate over the remaining lines to read edges and flow
    for line in file_stream:
        line = line.strip()
        if not line:
            continue
            
        try:
            # Each line has: u, v, f(e) 
            u, v, flow_value = map(int, line.split())
            
            # Store the edge and flow value in the dictionary
            flow_dict[(u, v)] = flow_value
            
        except ValueError:
            # Handle lines that don't have exactly 3 integers
            print(f"Skipping malformed edge line: {line}")
            continue
            
    return flow_dict,V,E


def clean_paths_and_cycles(paths, cycles, s, t):
    """
    Cleans the decomposition:
    - merges duplicate paths
    - merges duplicate cycles
    - filters out malformed entries
    - moves misclassified cycles into cycles[]
    - removes or repairs repeated-vertex issues
    """

    cleaned_paths = defaultdict(int)   # key = tuple(nodes), value = total weight
    cleaned_cycles = defaultdict(int)

    # -------------------------------------------------------
    # Helper: check if sequence is a simple path (no repeats)
    # -------------------------------------------------------
    def is_simple_path(nodes):
        return len(nodes) == len(set(nodes))

    # -------------------------------------------------------
    # Helper: check if sequence is a cycle
    # -------------------------------------------------------
    def is_cycle(nodes):
        return len(nodes) >= 2 and nodes[0] == nodes[-1]

    # -------------------------------------------------------
    # Phase 1: Normalize & classify PATHS
    # -------------------------------------------------------
    for w, nodes in paths:
        tup = tuple(nodes)

        # Path must start at s and end at t
        if nodes[0] != s or nodes[-1] != t:
            # Misclassified as cycle?
            if is_cycle(nodes):
                cleaned_cycles[tup] += w
            else:
                # If malformed → skip entirely
                continue
            continue

        # Simple path? (no duplicated internal nodes)
        if not is_simple_path(nodes):
            # If it forms a cycle instead → classify as cycle
            if is_cycle(nodes):
                cleaned_cycles[tup] += w
            continue

        # Valid path, merge duplicates
        cleaned_paths[tup] += w

    # -------------------------------------------------------
    # Phase 2: Normalize & classify CYCLES
    # -------------------------------------------------------
    for w, nodes in cycles:
        tup = tuple(nodes)

        if not is_cycle(nodes):
            # malformed: ignore or treat as path?
            continue

        # drop cycles with repeated internal nodes
        if len(set(nodes[:-1])) != len(nodes[:-1]):
            continue

        cleaned_cycles[tup] += w

    # Convert back into list[(w, [path])]
    final_paths = [(w, list(tup)) for tup, w in cleaned_paths.items()]
    final_cycles = [(w, list(tup)) for tup, w in cleaned_cycles.items()]

    # -------------------------------------------------------
    # Sort for stable output
    # -------------------------------------------------------
    final_paths.sort(key=lambda x: (-x[0], x[1]))   # by descending weight, then lexicographic
    final_cycles.sort(key=lambda x: (-x[0], x[1]))

    return final_paths, final_cycles


# ================================================================
# Example use
# ================================================================
if __name__ == "__main__":
    # Example small test flow: edges stored as { (u,v): flow }
    fileName = "test-instances/g01.graph"
    fileContents = ""    
    flow = {
        (1,2):5,
        (1,6): 15,
        (6,2):7,
        (2,3):12,
        (3,7):4,
        (3,4):8,
        (4,7):11,
        (4,6):8,
        (6,5):16,
        (5,4):11,
        (5,7):5
    }
    V=7
    E=0

    if len(sys.argv) >= 2:
        fileName = sys.argv[1]
        print("Input file:", fileName)
    else:
        print("No input file provided")
    
    try:
        with open(fileName, 'r') as file:
            fileContents = file.read()
            fileContentsStructured = read_flow_graph(fileContents)
            flow = fileContentsStructured[0]
            V = fileContentsStructured[1]
            E =fileContentsStructured[2]
    except FileNotFoundError:
        print("Error: The file 'filename.txt' was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")
    print(read_flow_graph(fileContents))
    print(fileContents)

    paths, cycles = decompose_flow(V, flow=flow, s=1, t=V)
    pathsOptimized, cyclesOptimized = clean_paths_and_cycles(paths,cycles, 1, V)

    P = len(pathsOptimized)
    C = len(cyclesOptimized)
    fileNameCommon = fileName.split("/")[1].split(".")[0]
    outputFileName = "outputs/" + fileNameCommon + ".out"


    # 3. Write to File
    with open(outputFileName, 'w') as f:
        # First line: |P| and |C|
        f.write(f"{P} {C}\n")
        
        # Path lines
        for path_line in pathsOptimized:
            weight = path_line[0]  # The integer weight (w(p))
            nodes = path_line[1]   # The list of integer vertices (v1, v2, ...)
            
            # Convert the list of ints to a space-separated string: "v1 v2 v3 ..."
            nodes_str = " ".join(str(v) for v in nodes)
            
            # Write the complete line: "w(p) v1 v2 v3 ...\n"
            f.write(f"{weight} {nodes_str}\n")

        # --- Cycle lines ---
        for cycle_line in cyclesOptimized:
            weight = cycle_line[0] # The integer weight (w(c))
            nodes = cycle_line[1]  # The list of integer vertices (v1, v2, ...)

            # Convert the list of ints to a space-separated string: "v1 v2 v3 ..."
            # Note: This uses the correct ' '.join() syntax and converts ints to strings.
            nodes_str = " ".join(str(v) for v in nodes)

            # Write the complete line: "w(c) v1 v2 v3 ...\n"
            f.write(f"{weight} {nodes_str}\n")
            
    print(f"\n✅ Successfully created file: '{outputFileName}'")
    print(f"   |P| = {P}, |C| = {C}")
    
